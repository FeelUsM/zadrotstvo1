существует "технология" память переводов
ее суть в том, чтобы одинаковые предложения переводились одинаковым способом
Если мы таким образом перевели некоторый текст, то потом переводить модифицированную версию этого текста будет гораздо проще, 
    т.к. надо будет перевести только измененные предложения.
Но какова вероятность встретить два одинаковых предложения в разных текстах?
    Если в предложении больше трех слов, то практически нулевая.
    
в этом тексте память переводов используется с другим смыслом
Предлагается сделать переводчик в котором единицей перевода будет не предложение, а фраза
    (словосочетания, слова - тоже являются фразами)
    причем английской фразе будет будет сопоставляться не ее перевод, а правило (алгоритм) генерации перевода
        фраза и правило перевода могут быть как очень простыми, так и очень сложными
    у одной и той же фразы может быть несколько смыслов, и соответственно, правил перевода
    совокупность фраз со всеми их правилами перевода - "память переводов" уровня языка - или проще говоря словарь фраз
в каждом конкретном тексте некоторая фраза имеет только один смысл (возможно с редкими исключениями)
    и выбор для каждой фразы варианта ее перевода из имеющихся - память переводов данного текста

==============================================================================

есть словарь фраз
есть память переводов (для каждого текста)

=== парсинг ===
(мульти)словарь фраз - ссылки от фраз на правила перевода
мульти - одна фраза может ссылаться на несколько правил
на одно правило перевода может идти несколько фраз

фраза - паттерн, который может использовать типы под-фраз, которые определяются выбранным правилом перевода этой фразы
паттерн - БНФ
тип подфразы - паттерн ИЛИ, использующий все фразы, имеющие этот тип
каждая фраза имеет один или несколько типов - сущ/глаг/прил/ или другая часть речи, которая может уточняться вопросом
типы фразы определяются типами правил, которыми может переводиться эта фраза

парсинг текста происходит по предложениям
предложение парсится по очереди типами фраз, начиная с глагольного (или стартовым паттерном, который который использует другие фразы)

фразу будем называть терминальной или лексической, если ее паттерн не использует типы фраз
    примеры: cat; fat(жирный)
иначе фразу будем называть синтаксической или грамматической
    пример: <прил> cat

фразу будем называть составной, если ее паттерн состоит из 
синтаксической фразы (ее будем называть основной (в составе составной)), где хотябы вместо одного типа используется 
конкретная фраза этого типа (такие фразы будем называть зависимыми (в составе составной))
    пример: fat cat
иначе фразу будем называть фразой 1-го уровня
фраза n-го уровня состоит из фраз n-1-го и ниже уровней
а также фраза A является основной, а фразы B и C являются зависимыми в составе фразы X,
то со фразой A связана информация, ссылающаяся на фразы B,C и X

технически пасинг выглядит так:
текст (на клиенте) разбивается на слова, и удаляются повторяющиеся слова, после чего на клиент загружяются все фразы 1го уровня, в которых они встречаются
производится парсинг, после чего, какие-то фразы в тексте нашлись, 
и после этого на клиент загружются те фразы 2-го уровня, на которые ссылаются те фразы 1-го уровня, которые нашлись в тексте (вместе с соответствующими зависимыми фразами).
в тексте ищутся фразы 2-го уровня в соответствующих местах...
и так далее
    например есть фраза [fat] и фраза [<прил> cat]
    на тексте [the fat cat] они будут найдены, и следовательно загрузится состовная фраза [fat cat]
    после чего она будет найдена, и она перекроет фразы [fat] и  [<прил> cat]


? как добавлять новые фразы, и что делать если текст можно распарсить разными способами ?
во первых каждое отдельное слово - изначально существующая фраза
а также как можно раньше надо сделать как можно более правильные грамматические фразы, чтоб они разбивали предложение с наибольшей глубиной вложенности
при коллизии фраз (один и тот же текст можно распарсить разными способами)
    у них сразу должна создаться (возможно вручную) составная фраза, 
    с набором правил, который является объединением наборов правил фраз, учавствующих в коллизии

> на этом этапе почти не учитываю морфологию, т.е. русский текст так не распарсишь
    хотя нет, распарсишь, только потребуется гораздо больше типов, различающихся по родам/числам/падежам/др_параметрам
    только для единообразия и упрощения должна быть связь между разными формами одного и того же слова
    и в переводе при выборе смысла он должен меняться у всех форм

=== перевод ===
каждая фраза может иметь нескоько смыслов, и соответственно несколько правил перевода
каким образом переводить ту или иную фразу - выбирает пользователь мышкой из выпадающего списка
после выбора* (или добавления) некоторого правила для некоторой фразы это правило записывается в память переводов данного текста, 
    и всегда, когда встречается эта фраза в этом тексте она по умолчанию будет переводиться этим правилом
* если в каком-то месте надо сделать исключение для для фразы, то из надфразы этой фразы как основной и этой фразы как зависимой
    создается состовная фраза, и добавляется в словарь фраз, после чего ей сопоставляется правило, в котором указано, 
    какие конкретно правила вызывать для основной и зависимой фразы, 
    а также эта составная фраза с этим правилом добавляется в память переводов этого текста.
* если у фразы нет надфраз, т.е. эта фраза - целое предложение, то наверно надо делать фразы между предложениями...
чтобы для каждого нового текста схожей тематики не создавать заного вручную память переводов,
    ее можно инициализировать от другого/других текстов

=== генерация ===
каждое правило перевода имеет тип и один единственный смысл этого типа
(текст, сгенерированный этим правилом, может иметь и другие смыслы, но один из них (по возможности главный и очевидный)
    должен быть тем, для которого предназначено это правило)
и возвращает текст этого типа ввиде дерева, чтобы над ним было удобнее производить преобразования
правила для синтаксических фраз принимают аргументы ввиде деревьев определенного типа
    синтаксические правила могут менять род/число/другие_параметры у своих аргументов
    а также изменять например глаголы на причастия/деепричастия или производить другие преобразования
    все эти преобразования возможны за счет существующей базы данных целевого языка**

также каждое правило может генерировать разные тексты одного и того же смысла, 
    выбор между которыми усуществляется случайным образом или с применением статистических методов
    чтобы небыло повторов слов в переводе и фраз типа масло масленое, а также из каких-нибудь других эстетических соображений
(цель перевода - не создать произведение искусства на целевом языке, а наиболее четко передать смысл)
    
=== простой пример ===
фраза (ф1)[big] имеет правило(п1), которое возвращает [большой] типа прил
фраза (ф2)[fat] имеет правила: (п2)[жирный] (п8)[полный] и (п9)[толсый] типа прил
фраза (ф3)[cat] имеет правила: (п3)[кошка] и (п4)[кот] типа сущ
фраза (ф4)[<прил> <суш>] имеет правило (п5)[[<прил (того же рода, что и сущ)>] <суш>] типа сущ
    также с ней ассоциировано, что при аргументах (ф2) в качестве прил и (ф3)в качестве сущ она должна заменяться на (ф6)
фраза (ф5)[fat cat] имеет правила: (п6)[[полная] кошка] и (п7)[[толстый] кот] 
текст [big fat cat] с памятью переводов ф5-п6 будет переводиться так:
    фраза ф4 требует прил, т.е. ф1 или ф2, сработает ф1 (а ф2 не сработает), и big будет прочитано
    далее ф4 требует сущ, т.е. ф3 или ф4 (ф5 еще не загружена)
        ф3 не может быть прочитано (fat != cat)
        пытаемся прочитать ф4, 
            она требует прил, т.е. ф1 или ф2, и сработает ф2 (а ф1 не сработает), и fat будет прочитана 
            далее ф4 требует сущ, т.е. ф3 или ф4 (ф5 еще не загружена), и сработает ф3 (а ф4, если все это еще раз проделать, не сработает), и будет прочитано cat
            так как это ф4 с аргументами ф2 и ф3, то она замениться на ф5 (можно даже повторно не парсить)
            
            ф5 по памяти переводов переводится правилом п6
        и возвращает [[полная] кошка] типа сущ, с атрибутом ж.р.
        ф1 имеет одно правило п1 и возвращает [большой] типа прил
    ф4 преобразовывает [большой] в ж.р. и возвращает [[большая] [[полная] кошка]]
        
     
=== мультилингва ===
поскольку каждое "правило" перевода имеет один единственный смысл
то ему можно сопоставить алгоритмы генерации текста для разных целевых языков
а также для разных исходных языков можно сделать свои фразы с алгоритмами парсинга

=== создание словаря фраз ===
каждый раз, когда требуется внести изменение в перевод, надо выбрать:
изменить смысл фразы во всем тексте
создать новую составную фразу-исключение
изменить правило, т.к. от изменения перевода в этом месте смысл не меняется
да и выбрать оптимальный размер памяти переводов - для абзаца/старницы/главы 
- достаточно сложно

по этому автоматическая генерация словаря фраз из существующих пар текстов на мой взгляд невозможна
максимум, что можно сделать автоматически - это загрузка существующих словарей слов и маленьких фраз
остальное лучше предоставить пользователям в wiki-формате:
каждый может изменить словарь фраз, и в любой момент это изменение можно откатить

==============================================================================
wiki переводчик с памятью переводов для разных текстов
переводчик на основе правил, 
	предоставляющий варианты выбора и делающий умные выборы вариантов по умолчанию (на основе памяти переводов)
	правила которого могут менять и добавлять пользователи
		варианты выбора нужны чтобы нек. фразу в одном тексте переводить одним способом, а в другом - другим

=== дальще идет предыдущая абстрактная версия алгоритма и конкретные архитектурные решения на далекое будущее ===
=== вот его примерный алгоритм ===
1. распарсить синтаксис английского предложения (вопросы между словами, и ссылки от английских слов он, оно..., этот, эти...) 
	пользователи смогут задавать свои предложения БНФ
(выбрать вариант (по умолчанию тот, у которого найдена самая частная фраза...))
2. найти англ. фразы 
	фраза - паттерн на структуру
		паттерн состоит из переменных (выражений) и константных слов.
		немного похоже на сопоставление с образцом в хаскеле или на БНФ
	с каждым англ. словом ассоциированы англ. фразы, в которых оно содержится (слово может встречаться во фразе несколько раз)
	поиск идет так: по каждому слову предложения проверяются все ассоциированные со словом фразы-паттерны на соответствие предложению в ~этих~ местах
	т.о. фразы могут перекрываться.
		вкл. одной фразы может запрещать доступ к другим фразам
предложение переводится стандартным алгоритмом, но, 
	если в нем найдены (и не отключены) фразы (первого уровня), то они переводятся правилами этих фраз.
	эти фразы могут содержать выражения, которые переводятся стандартным алгоритмом, но,
		если в выражении найдутся фразы (второго уровня), то они будут переводится правилами этих фраз
		и т.д.
(выбрать фразы, которые хотим отключить, т.е. переводить не правилами этих фраз, 
	а по отдельности подфразы (если есть), и соединять их стандартным алгоритмом 
	(а подфразы - правилами этих подфраз (слово - частный случай фразы)) 
	и разрешить конфликты)
(при выборе по умолчанию
	если паттерн одной фразы полностью подходит под паттерн другой, 
	то используется более частная (крупная) фраза,
	иначе это конфликт, который надо разрешать вручную, или какой-нибудь приоритет для фраз сделать...)
3. выполнить правила переводов фраз и дефолтный алгоритм перевода(вокруг фраз). Фразы могут быть вложены.
	каждое правило генерирует выражение на русском языке со структурой, т.ч. это выражение имеет тип (часть речи), и при его склонении/спряжении/...
	меняются окончания не только у главного слова, но и окончания у всех зависимых слов (напр. парное молоко, парного молока, парным молоком)
	в каждое правило передаются аргументы (могут отсутствовать) - переменные (выражения) из фраз
	одно и то же правило можно использовать в разных фразах, если в них одинаковые параметры (по количеству и типам)
	для одной фразы может быть несколько правил перевода
		правила могут быть невероятно простыми (например заменить англ. фразу без (под)выражений на определенную русскую)
			т.о. правило перевода фразы может задать даже начинающий пользователь
		правило может преобразовывать** подвыражения
		правило может варианты переводов исх. слова преобразовать** и попросить выбрать из преобразованных
(выбрать для каждой фразы, каким правилом ее переводить и слова/словосочетания по просьбе правил
	по умолчанию в данном тексте выбирается тот вариант, который выбирался раньше в данном тексте для данной фразы
                т.е. каждая фраза в тексте переводится только одним способом.
!!!		это память переводов фраз для данного текста
		ее можно наследовать/копировать из других текстов
                    если в каком-то месте фраза переводится другим способом, 
                    то над-фраза или даже все предложение попадает в память переводов предложений
                        
	память переводов отделена от текста
	
	
	в словаре фраз должны содержаться фразы и словосочетания (помимо просто слов)
	надо стараться избегать, чтобы в словарь фраз попадали целые предложения или большие фразы
                даже, если это предложение не встретиться в других текстах, оно может встретиться в других версиях этого текста
		но, скорее всего в некоторых случаях, от конкретных указаний, как какое предложение переводить, избавиться не получится
		но количество этих случаев надо свести к минимуму
	аналогичным образом определять классы css для фрагментов (например код), которые не надо переводить, 
		но комментарии и идентификаторы в комментариях - надо
		> надо быть готовым к большому кол-ву багов в этом месте
)
4. (выбрать конечный порядок слов)

> придумать формат памяти переводов и указаний к переводу предложений
> придумать дефолтный алгоритм перевода и откалибровать на практике
	если какая-то фраза может переводиться не одним способом, 
	то это точно правила фразы, а не части дефолтного алгоритма
>> слабое место всего этого переводчика - это "умные" выборы вариантов по умолчанию, но я думаю, это тоже можно откалибровать на практике
	(главное - 1: предоставить все возможные варианты для выбора пользователем, 2: автоматизировать рутинные действия пользователя (память переводов уже большую часть автоматизирует)).
некоторая фраза может переводиться разными способами, но при этом все способы имеют один и тот же смысл
	тогда эти способы надо чередовать в случайном порядке, а в БД отметить их как взаимозаменяемые

=== БД: ===
англ. слова
	ссылки на фразы, в которых они содержатся (вычисляется автоматически)
англ. фразы (частный случай - англ. слова)
	ссылки на правила перевода
правила перевода
	ссылки на ру_слова (однозначные) и/или на ру_слова с уточнением смысла + взаимозаменяемость
русские слова с уточнением смысла
	ссылка на (слово, склонение) + ссылка на wiki
русские слова
	разные склонения/спряжения, + ссылка на wiktionary
	+ ссылка на wiki, возможно disambiguition (неоднозначное)
	
** есть определенные взаимосвязи между __ == атрибуты у __, ссылающиеся на __
	где __ - ру_слова (однозначные) и/или ру_слова с уточнением смысла
это нужно для замен (в правилах) типа: пикирующий<->который пикирует
каждое слово/фраза имеет тип: сущ., прил., глаг., подлежащее-сказуемое...
> надо проработать систему типов основанную на частях речи (начать с какой-то и откалибровать на практике)

=== как можно организовать ===
т.к. много чего будет калиброваться на практике, нужен язык, позволяющий легко это делать
например лисп или джаваскрипт 

перевод осуществлять в браузере пользователя(джаваскрипт), а на сервере хранить только БД
на клиент загружаются
	все англ. фразы, в которых встречаются слова текста.
	и (все русские слова (возможно с уточнением смысла) и русские слова, на которые ссылаются русские слова с уточнением смысла)
	которые используются в правилах, на которые ссылаются фразы
		или обновляются (в LocalStorage браузера) те которые уже загружены и были изменены другими пользователями
		запросы типа: 
			вот набор этих слов - загрузить, 
			набор этих слов - обновить с этого момента, 
			а набор этих слов - обновить с того момента.
		может быть стоит сформировать набор самых употребляемых слов, и не передавать в запросе все слова
			а только указание этого набора и последнюю дату его обновления.

> сделать скрипт (аналогичный mathjax), который можно будет встраивать в сайты, который будет 
	создавать GUI, 
	при выборе фраз и правил - обращаться серверу этого сайта за памятью переводов страниц с этого сайта
	давать возможность копировать/инициализоровать память переводов
	при редактировании фраз и правил - обращаться к вики-серверу фраз и правил
> сделать отдельный проэкт - хранилище памяти переводов любого сайта, 
	тексты можно идентифицировать при помощи URI, и память переводов для них хранить на общем для всего мира сервере
	GUI - аналог гугл-переводчика сайтов
	и, возможно в дальнейшем, плагины к браузерам, которые будут внедрять исх. код в код страниц
	на сайтах, где разным пользователям выдается один и тот же контент, 
		клиент может отправлять на сервер не список всех слов текста, а только его URL, 
		а на сервере уже будут закэшированы слова из того текста.

редактирование и хранение слов и фраз удобно привязать к вики-движку, у которого для каждого типа слов и фраз надо сделать 
	отдельный способ отображения и редактирования wisiwig (исходный код можно хранить например в JSON формате)

> научиться в своих скриптах получать доступ к википедии/викисловарю и к wiki-коду страниц от туда
> ? бежать кодить, или попытаться это попробовать вручную ?
изучить XAMPP, PHP, mediawiki, SemanticForms
добавить страничку, с которой можно будет слать любые XHR запросы к БД mediawiki - API
начать прорабатывать систему типов, 
начать добавлять фразы-слова и правила к ним
начать делать дефолтный алгоритм (с примитивным GUI-ем), и иногда добавлять более сложные фразы, 
добавить GUI в mediawiki
начать делать хранилище памяти переводов с GUI-ем как у гугла, внутри - скрипт, который можно было бы встраивать в другие сайты
начать сайтам предлагать встраивать переводчик к себе для рекламы переводчика
...
profit
...
начать сайтам предлагать встраивать переводчик к себе, и хранить память переводов у себя (для уменьшения нагрузки на общий сервер памяти переводов) 


гранты википедии!!!
